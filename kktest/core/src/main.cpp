#include "kktest/core/src/main.hpp"

#include "kktest/core/src/driver.hpp"
#include "kktest/core/src/hooks_manager.hpp"

using namespace cppli;
using namespace std;

namespace kktest {

void initialize(int argc, char** argv, vector<Extension*>* extensions) {
    Parser parser("Test binary. Generated by The KKTest Framework.");

    parser.addHelpFlag();
    auto executorTypeArgument = parser.addChoiceArgument(
            ChoiceArgumentSpec<ExecutorType>("executor")
                .setDescription("Choose the type of executor to use. A smooth "
                                "executor runs all tests in the same process, "
                                "while a boxed executor runs each test in a "
                                "separate process. Using a smooth executor "
                                "means a test killed by signal will not be "
                                "detected and will kill the whole test suite.")
                .setOptions({
                    {"smooth", SMOOTH_EXECUTOR},
                    {"boxed", BOXED_EXECUTOR}
                })
                .setDefaultValue(BOXED_EXECUTOR));
    auto numBoxesArgument = parser.addNumericArgument(
            NumericArgumentSpec<size_t>("num-boxes")
                .setDescription("Maximum number of tests to execute in parallel"
                                " (processes to spawn). Ignored if `executor` "
                                "type is not 'boxed'.")
                .setDefaultValue(1u)
                .setImplicitValue(1u));

    for (Extension* extension : *extensions) {
        extension->registerCommandLineArgs(parser);
    }

    parser.interpret(argc, argv);

    HooksManager api;
    for (Extension* extension : *extensions) {
        extension->init(api);
    }

    ExecutorType executorType = executorTypeArgument.get();
    size_t numBoxes = max(numBoxesArgument.get(), 1ul);

    Driver::Init(api, executorType, numBoxes);
}

int runTests(vector<TestCase> tests, vector<Extension*>* extensions) {
    auto driver = Driver::Instance();

    int ret = 1;
    try {
        for (TestCase& testCase : tests) {
            driver->addGroup(move(testCase.name), testCase.body);
        }
        ret = driver->clean();
    } catch(const ConfigurationError& error) {
        driver->forceDestroy(error);
    }

    for (Extension* extension : *extensions) {
        extension->destroy();
        delete extension;
    }

    delete driver;

    return ret;
}

}
