#include "kktest/core/src/main.hpp"

#include "kktest/core/src/driver.hpp"
#include "kktest/core/src/extension_api.hpp"

using namespace cppli;
using namespace std;

namespace kktest {

int main(int argc, char** argv,
         vector<TestCase>&& tests,
         const vector<Extension*>& extensions) {
    Parser parser("Test binary. Generated by The KKTest Framework.");

    parser.addHelpFlag();
    parser.addTerminalFlag(
            FlagSpec("version")
                    .setShortName("v")
                    .setDescription("Display program version."),
            "KKTest generated test-case.\nKKTest version: " KKTEST_VERSION"\n");
    auto smoothFlag = parser.addFlag(
            FlagSpec("smooth")
                .setDescription("Run all tests within the same process"
                                " (useful for step-by-step debugging).")
                .setShortName("s"));
    auto maxParallelTestsArgument = parser.addNumericArgument(
            NumericArgumentSpec<size_t>("max-parallel-tests")
                .setDescription("Maximum number of tests to execute in parallel"
                                " (processes to spawn). Ignored if `smooth` "
                                "flag is enabled.")
                .setDefaultValue(1u)
                .setImplicitValue(1u));

    for (Extension* extension : extensions) {
        extension->registerCommandLineArgs(parser);
    }

    parser.interpret(argc, argv);

    ExtensionApi api;
    for (Extension* extension : extensions) {
        extension->init(api);
    }

    bool smooth = smoothFlag.get();
    size_t numBoxes = max(maxParallelTestsArgument.get(), 1ul);

    Driver* driver = Driver::init(api, smooth, numBoxes);

    int ret = 1;
    try {
        for (TestCase& testCase : tests) {
            driver->beforeTestCase(testCase.name);
            testCase.run();
            driver->afterTestCase();
        }
        ret = driver->clean();
    } catch(const ConfigurationError& error) {
        driver->forceDestroy(error);
    } catch(const ExpectationFailed& error) {
        driver->forceDestroy(ConfigurationError(
                string("Expectation failed in global scope: ") + error.what()));
    } catch(const exception& error) {
        driver->forceDestroy(ConfigurationError(
                string("Exception thrown in global scope: ") + error.what()));
    } catch(...) {
        driver->forceDestroy(ConfigurationError(
                "Non-exception object thrown in global scope."));
    }

    for (Extension* extension : extensions) {
        extension->destroy();
        delete extension;
    }

    delete driver;

    return ret;
}

}
